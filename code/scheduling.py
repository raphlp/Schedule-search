import itertoolsimport mathimport heapqimport matplotlib.pyplot as pltimport os# Task set: (C, T)tasks = [    (2, 10),    (3, 10),    (2, 20),    (2, 20),    (2, 40),    (2, 40),    (3, 80)]def lcm(x, y):    return x * y // math.gcd(x, y)def compute_hyperperiod(tasks):    hyper = 1    for _, T in tasks:        hyper = lcm(hyper, T)    return hyperdef generate_jobs(tasks, hyperperiod):    jobs = []    for task_id, (C, T) in enumerate(tasks):        for k in range(hyperperiod // T):            aij = k * T            dij = aij + T            jobs.append((aij, dij, C, task_id, k))    jobs.sort()  # Sort by arrival time    return jobsdef simulate_schedule(current_time, ready_jobs):    """Simulate all possible orderings and return the best one minimizing total waiting."""    min_total_wait = float('inf')    best_order = None    for perm in itertools.permutations(ready_jobs):        time = current_time        total_wait = 0        feasible = True        for dij, aij, cij, task_id, job_id in perm:            if time < aij:                time = aij  # Wait for job to arrive            finish_time = time + cij            if finish_time > dij:                feasible = False                break            wait_time = time - aij            total_wait += wait_time            time = finish_time        if feasible and total_wait < min_total_wait:            min_total_wait = total_wait            best_order = perm    return best_orderdef non_preemptive_schedule(tasks, allow_task5_late=False):    hyperperiod = compute_hyperperiod(tasks)    all_jobs = generate_jobs(tasks, hyperperiod)    pending_jobs = []    schedule = []    job_log = []    time = 0    idx = 0    while time < hyperperiod:        # Fetch arriving jobs        while idx < len(all_jobs) and all_jobs[idx][0] <= time:            aij, dij, cij, task_id, job_id = all_jobs[idx]            heapq.heappush(pending_jobs, (dij, aij, cij, task_id, job_id))            idx += 1        if pending_jobs:            # If ready jobs exist            candidates = list(pending_jobs)            best_order = simulate_schedule(time, candidates)            if best_order:                for job in best_order:                    pending_jobs.remove(job)                    dij, aij, cij, task_id, job_id = job                    if time < aij:                        time = aij                    start_time = time                    end_time = time + cij                    # Special case if allow_task5_late                    if allow_task5_late and task_id == 4:                        pass  # Ignore τ5 deadline checking                    else:                        if end_time > dij:                            raise Exception(f"Deadline miss for Task {task_id+1} Job {job_id+1} at time {time}")                    job_log.append((task_id, job_id, aij, start_time, end_time, dij))                    # Logging each scheduled moment                    for t in range(start_time, end_time):                        schedule.append((t, task_id))                    time = end_time            else:                # No feasible scheduling (should not happen unless task5 allowed to miss)                time += 1        else:            # No ready job: fast-forward to next job arrival            if idx < len(all_jobs):                time = all_jobs[idx][0]            else:                break    return schedule, job_log, hyperperioddef save_gantt(schedule, tasks, hyperperiod, filename):    fig, ax = plt.subplots(figsize=(16, 5))    colors = plt.cm.get_cmap("tab10")    task_count = len(tasks)    for t, task_id in schedule:        if task_id is not None:            inverted_task_id = task_count - 1 - task_id            ax.broken_barh([(t, 1)], (inverted_task_id * 5, 4), facecolors=colors(task_id))    ax.set_xlim(0, hyperperiod)    ax.set_xlabel("Time")    ax.set_yticks([i * 5 + 2 for i in range(task_count)])    ax.set_yticklabels([f"Task {task_count - i}" for i in range(task_count)])    ax.set_title("Non-Preemptive Scheduling - Optimal Total Waiting Time")    plt.tight_layout()    os.makedirs("figures", exist_ok=True)    plt.savefig(f"figures/{filename}.png")    plt.close()def main():    # Full strict scheduling    schedule, job_log, hyper = non_preemptive_schedule(tasks)    save_gantt(schedule, tasks, hyper, "gantt_strict")    # Scheduling allowing τ5 to miss deadline    schedule2, job_log2, hyper = non_preemptive_schedule(tasks, allow_task5_late=True)    save_gantt(schedule2, tasks, hyper, "gantt_task5_late")    # Print job logs    print("Strict Scheduling:")    for task_id, job_id, aij, start, end, dij in job_log:        print(f"Task {task_id+1} Job {job_id+1}: Arrival={aij}, Start={start}, End={end}, Deadline={dij}")    print("\nScheduling allowing τ5 to miss deadline:")    for task_id, job_id, aij, start, end, dij in job_log2:        print(f"Task {task_id+1} Job {job_id+1}: Arrival={aij}, Start={start}, End={end}, Deadline={dij}")if __name__ == "__main__":    main()